1. 調用minisat的solveLimited方法，
inline lbool    Solver::solveLimited  (const vec<Lit>& assumps){ assumps.copyTo(assumptions); return solve_(); }

观察到方法将传入的assumps数组拷贝到assumptions数组再执行了solve_(),
如果直接在assumptions数组内构造，省去一次数组拷贝可以更快。

2. inputNums是否有可能比minisat中model的size更大？

3. minimal update level 为何不是仅在SAT返回false并添加uc时修改？ 原checker.cpp line 232

4. 执行SAT(s, Fi)后返回UNSAT，按照原先的simplecar实现，会考虑做SAT(s, Fi+1)，如果s 被Fi+2中的uc block掉，那么就不会做SAT(s, Fi+1)，这是正常的，但是也不会去做 SAT(s, Fi+2)等，状态s的尝试会直接结束。
那么这一点要不要复刻？

对应代码//notes 4

5. oski15a01b09s.aig 原先很好解，28秒出结果，有反例，但是重构版就是解不出。观察到两个版本的搜索路径不同，理论上同样的输入（模型中的转移关系和assumption），拿到的输出(getAssignment)应当是一样的，但是实际上不一样，原因不明。
类似的还有
oski2b5i
oski2ub0i
oski3b0i
pdtswvibs8x8p0
texasparsesysp3
这些例子都非常简单，原来均在60s之内解决。